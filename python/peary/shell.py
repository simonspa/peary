# coding: utf-8
"""
Shell-like command line client to pearyd.
"""

from __future__ import print_function

import argparse
import cmd
import functools
import inspect

from . import PearyClient, Device

# helper functions

def ensure_number(x):
    """
    Convert the argument to an appropriate number type if possible.
    """
    try:
        return int(x)
    except ValueError:
        pass
    try:
        return float(x)
    except ValueError:
        pass
    return x

def print_result(value):
    """
    Pretty printing with a bit of intelligence.
    """
    if value is None:
        return
    elif isinstance(value, list):
        for x in value: print(x)
    else:
        # automatically decodes bytes
        print(str(value, encoding='utf-8'))

class PearyShell(cmd.Cmd):
    """
    Shell-like command line client to pearyd.

    To avoid code duplication, the available commands are
    automatically generated by introspecting the relevant objects
    in the python library itself.
    """
    intro = '\n'.join([
        'Welcome to peary',
        '',
        'Type help to list commands, help <command> for details',
        'Type exit or CTRL-D to exit',
        '',
    ])
    prompt = '(peary) '

    def __init__(self, client, **kw):
        super(PearyShell, self).__init__(**kw)
        self.client = client
        self.intro += '\nConnected to {}\n'.format(client.peername)

    def onecmd(self, line):
        # client throws on error, but we want to continue the cli loop
        try:
            return super(PearyShell, self).onecmd(line)
        except Exception as err:
            print('Error: {}'.format(err))
    def emptyline(self):
        # empty line is a no-op
        pass
    def default(self, line):
        """
        Handle unknown commands.
        """
        # try to interpret unknown commands as dynamic per-device commands
        # the line has to contain at least a cmd name and a device identifier
        parts = line.split()
        if len(parts) < 2:
            print('Error: unknown command \'{}\''.format(line))
            return False
        # any exceptions thrown are handled later by `onecmd`
        # structure: cmd [args...] device_id
        device = self.client.get_device(int(parts[-1]))
        cmd = parts[0]
        args = [ensure_number(_) for _ in parts[1:-1]]
        func = getattr(device, cmd)
        print_result(func(*args))
        # TODO register function also in shell interface

    def do_exit(self, arg):
        """Exit the client."""
        return True
    def do_EOF(self, arg):
        """Exit the client (invoked via CTRL-D)."""
        return True

# cmd.Cmd expects commands to take a single string argument that contains
# all parameters. To simplify calling existing commands the following code
# takes carse of parsing the parameters string, convert parameters to
# appropriate types, and to call the underlying function.
# The function doc string is automatically generated from the doc string
# of the underlying function and a generated description of the function
# signature.

# TODO inspect number of required arguments

def make_doc_with_signature(member_func, is_device_function=False):
    """
    Combine existing function doc with signature description.
    """
    spec = inspect.getfullargspec(member_func)
    # always ignore initial `self` argument
    names = spec.args[1:]
    if is_device_function:
        # add device_id at the end
        names.append('device_id')
    if names:
        doc_sig = 'Arguments: '
        doc_sig += ' '.join(_.upper() for _ in names)
    else:
        doc_sig = 'No arguments'
    doc_orig = inspect.getdoc(member_func)
    if doc_orig:
        return '\n'.join([doc_orig, '', doc_sig])
    else:
        return doc_sig

def make_client_command(name):
    func = getattr(PearyClient, name)
    # structure: cmd [args...]
    @functools.wraps(func)
    def do_func(self, arg):
        args = arg.split()
        args = [ensure_number(_) for _ in args]
        print_result(func(self.client, *args))
    do_func.__doc__ = make_doc_with_signature(func, False)
    return do_func

def make_device_command(name):
    func = getattr(Device, name)
    # structure: cmd [args...] device_id
    @functools.wraps(func)
    def do_func(self, arg):
        args = arg.split()
        args = [ensure_number(_) for _ in args]
        device_id = args[-1]
        device = self.client.get_device(device_id)
        print_result(func(device, *args[:-1]))
    do_func.__doc__ = make_doc_with_signature(func, True)
    return do_func

# find commands by introspection and make them available in shell

def list_public_methods(obj, ignore=[]):
    ignore = set(ignore)
    for name in dir(obj):
        if name.startswith('_'):
            continue
        if name in ignore:
            continue
        # ismethod only works for
        # if name is not inspect.ismethod(getattr(obj, name)):
        #     continue
        yield name

for name in list_public_methods(PearyClient, ignore=['get_device', 'peername']):
    setattr(PearyShell, 'do_{}'.format(name), make_client_command(name))
for name in list_public_methods(Device):
    setattr(PearyShell, 'do_{}'.format(name), make_device_command(name))

def main():
    p = argparse.ArgumentParser(description='Peary client shell')
    p.add_argument('host', nargs='?', default='localhost',
                   help='host address (default=%(default)s)')
    args = p.parse_args()

    with PearyClient(host=args.host) as client:
        sh = PearyShell(client)
        sh.cmdloop()

if __name__ == '__main__':
    main()
